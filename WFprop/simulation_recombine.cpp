/*
  This program propagates populations constructed from genomes generated by a neutral coalescent model, FastSimCoal, available at: http://cmpg.unibe.ch/software/fastsimcoal2/

  Input files are .arp

  A population comprised of diploid individuals is propagated under the Wright-Fisher drift model

  The code can be compiled using a make command, and run by using the executable ./comp_sim_recombine.

  Functional options to the code can be specified at the command line and are as follows:

	--N           [n]   Set the population size to n.  Default is 1000.

	--F           [fl]  Number of founding genomes. Default is 20.

	--tSim        [t]   Run the simulation for t generations.  Default is 300.

	--depth       [d]   Read depth for sequencing, modelled as a Binomial distribution. Default is 100.
	
	--nseqs       [ns]  Number of sequences in .arp file.
	
	--s_out       [so]  Number of sequences exported that belong to the F set.

	--seed        [s]   Set the random seed to s.  Default is the machine time.

	--sel_loc     [sl]  Locus under selection. Default is generated randomly.

	--samp_freq   [sf]  Outputs allele frequencies from the population every (represents the process of sequencing). Default is every 10 generations.

	-- sigma      [S]   Fitness advantage of the selected allele is S (neutral is 0).  Default is 0.

	-- rho        [r]   Rate of recombination per nucleotide per generation is r.  Default is 1e-8.

	-- samp_freq  [F]   Outputs allele frequencies from the population every F generations.  Default is 1000.

	-- file       [f]   Input file name is f.  Default is n2000_1_1_1.arp.

	-- mu         [m]   Rate of mutation per nucleotide per generation is m. Default is 3*1e-9.


 Dr. Christopher J.R. Illingworth, Department of Genetics, University of Cambridge, 2017


Example:

Under neutrality, no recombination, no mutation

./comp_sim_recombine --N 1000 --F 20  --tSim 300 --samp_freq 10 --s_out 1000 --file n2000_1_1_1.arp

*/

#include <iostream>
#include <vector>
#include <list>
#include <deque>

using namespace std;

#include "shared.h" // Where all structures and function are defined

vector<trajectory> traj; 

vector<haplo> population;

vector<haplo> pop_temp;

vector<haplo> pop_sample;

int main(int argc, const char **argv){

	run_params p;

	// Read parameters from command line
	GetParameters(p,argc,argv);
	
	int n_seqs=2000; //Number of sequences in the fastsimcoal .arp file
	
	int F=p.F; //Number of founder lines for the population to be propagated

	//Set up random number generator
	gsl_rng_env_setup();
	gsl_rng *rgen = gsl_rng_alloc (gsl_rng_taus);
	gsl_rng_set (rgen, p.seed);

	//Input data
	ifstream arp_file;
	arp_file.open(p.file.c_str());
	
	ofstream par_file;

	par_file.open("Job_parameters.dat"); // Output file for simulation parameters
		
	int pop_size=p.N; //Simulation runs with diploid population

	cout << "Population " << pop_size << "\n";

	vector<int> diff_pos;

	vector<string> seqs;

	double c1=(pop_size+0.)/p.F; // Starting population is construccted from F sequences
	int c2=floor(pop_size/p.F);
	cout << "C " << c1 << " " << c2 << "\n";
	if (c1-c2>0.000001||c1-c2<-0.0000001) {
		cout << "Error: Population size is not divisible by number of founder haplotypes\n";
		return 0;
	}
	
	int s_print=p.s_out;

	// Read data from .arp file
	ReadData(p,pop_size,n_seqs,s_print,arp_file,diff_pos,seqs,population,rgen);

	int gen_length=diff_pos[diff_pos.size()-1]-diff_pos[0]+1;
	cout << "Genome Length " << gen_length << "\n";
	
	
	//Initial parameters
	int L=population[0].seq1.size();
	int N=p.N;
	int tSim=p.tSim;
	double mu=p.mu;  // mutation rate
	double sigma=p.sigma;  //Need to set allele under selection...
	double rho=p.rho; // recombination rate

	cout << L << "\n";
	
	par_file << "Population size " << N << "\n";
	par_file << "Founder lines " << F << "\n";
	par_file << "Mutation rate " << mu << "\n";
	par_file << "Recombination rate " << rho << "\n";
	par_file << "Selection coefficient " << sigma << "\n";
	par_file << "Sequencing depth " << p.depth << "\n";
	int min_sample=1; // output parameter
	
	
	//Output sample depth at each time point in file
	ofstream depth_file;
	
	depth_file.open("Sample_depths.dat");
	
	//Read in sample times
	vector<int> times;
	if (p.samp_freq==0) {
		ifstream time_file;
		time_file.open("Times.in");
		string s;
		int t;
		do {
			if (!(time_file >> t)) break;
			times.push_back(t);
		} while (1==1);
		times.push_back(0);
	}
	
	
	//Generate nucleotide count at each locus
	vector<nuc> nucs;
	GetNucleotides (nucs,population);
	
	vector<amap> alleles;
	GetAlleles(p,alleles,nucs);

	ofstream al_file;

	al_file.open("Alleles.out");
	

	for (int i=0;i<alleles.size();i++) {
		al_file << alleles[i].n1 << " " << alleles[i].n2 << "\n";
	}
	
	int sel_loc=0;
	char allele=' ';
	
	// Get allele at the position where selection is imposed
	
	GetSelectedAllele (pop_size,L,sel_loc,allele,nucs,rgen);

	if (p.sel_loc>=0) {
		sel_loc=p.sel_loc-1;
		GetSelectedAllele2 (pop_size,L,sel_loc,allele,nucs,rgen);
	}
	
	
	
	//Assign fitness vector - only one locus involved at the moment...
	vector<double> fitness;
	fitness.resize(L);
	fitness[sel_loc]=sigma;
	double h=0.5;
	
	//Get population fitness values
	for (unsigned int i=0;i<population.size();i++) {
		population[i].fitness=FindFit(sel_loc,allele,population[i].seq1,population[i].seq2,fitness,h);
	}
	
	vector<hap_loc> mutants;
	vector<double> p_select;
	vector<double> freqs;
	ofstream out1_file;
	AlleleFreqs (alleles,population,freqs);


	//Time-dependent data

	ofstream out_file;

	out_file.open("Time_resolved_freqs.dat"); // hidden frequencies
	
	ofstream sample_file;
		
	sample_file.open("Time_resolved_sample.dat"); // sampled frequencies at desired depth

	vector<dat_store> time_dat;

	vector<dat_store> time_sample;

	for (int i=0;i<diff_pos.size();i++) {
		dat_store d;
		d.position=diff_pos[i];
		time_dat.push_back(d);
		time_sample.push_back(d);
	}
	for (int i=0;i<freqs.size();i++) {
		time_dat[i].freqs.push_back(freqs[i]/(2*N));
		int samp=floor(gsl_ran_binomial(rgen,freqs[i]/(2*N),p.depth));  //Sample of given depth
		time_sample[i].freqs.push_back(samp);
	}
	depth_file << p.depth << "\n";

	int sample_freq=p.samp_freq; 
	
	
	cout << "Number of distinct haplotypes " << population.size() << "\n";
	
	int t_c=0;  //Index in vector of times


	// Start froward propagation
	
	for (int t_k=1;t_k<=tSim;t_k++) {
	

		//Find the number of mutations at this time point and their locations
		mutants.clear();
		FindHapMutationLoci(L,mu,population,mutants,rgen);
	
		MakeMutatedHaplotype(sel_loc,allele,h,fitness,mutants,alleles,population,rgen);

		
		CombineHapSame (L,population);
		DeleteEmptyHap(population,pop_temp);
		CopyHap(pop_temp,population);
		

		//Selection : Find global fitness
		double glob_fit=GlobalFit(population);
	

		//Find selection probabilities
		p_select.clear();
		HapSelProbs(glob_fit,p_select,population);
		
		//Find next generation
		HapNextGeneration(N,rgen,p_select,population);

		//Remove empty haplotypes
		DeleteEmptyHap(population,pop_temp);
		CopyHap(pop_temp,population);

		//Standard recombination
		vector<inpair> parents;
		parents.resize(N);
		ChooseParents(N,parents,population,rgen);
		CalculateRecombination(L,rho,gen_length,sel_loc,allele,h,fitness,diff_pos,parents,population,rgen);
		ConstructPopulation (sel_loc,allele,h,fitness,parents,population);

		CombineHapSame (L,population);
		DeleteEmptyHap(population,pop_temp);
		CopyHap(pop_temp,population);
		
		//First option to sample every p.samp_freq generations
		if (t_k>0&&p.samp_freq>0&&t_k%sample_freq==0) {
			
			freqs.clear();
			AlleleFreqs (alleles,population,freqs);
			for (int i=0;i<time_dat.size();i++) {
				time_dat[i].freqs.push_back(freqs[i]/(2*N));
				int samp=floor(gsl_ran_binomial(rgen,freqs[i]/(2*N),p.depth));

				time_sample[i].freqs.push_back(samp); 
			}
		}
		
		//Second option to sample at specified times
		if (p.samp_freq==0&&t_k==times[t_c]) {
			
			freqs.clear();
			AlleleFreqs (alleles,population,freqs);
			for (int i=0;i<time_dat.size();i++) {
				time_dat[i].freqs.push_back(freqs[i]/(2*N));
				int samp=floor(gsl_ran_binomial(rgen,freqs[i]/(2*N),p.depth));
				time_sample[i].freqs.push_back(samp);
			}
			t_c++;
		}
		
	}
	
	//Calculate allele frequencies
	
	freqs.clear();

	AlleleFreqs (alleles,population,freqs);
	
	//Output time-resolved data

	int st=0;

	for (int i=0;i<time_dat.size();i++) {
		st=0;

		for (int j=0;j<time_dat[i].freqs.size();j++) {

			out_file << time_dat[i].position << " "<< st<< " ";
			out_file << time_dat[i].freqs[j];
			out_file << "\n";
			st=st+sample_freq;
		}

	}

	for (int i=0;i<time_sample.size();i++) {
		st=0;

		for (int j=0;j<time_sample[i].freqs.size();j++) {

			sample_file << time_sample[i].position << " "<< st << " ";
			sample_file << time_sample[i].freqs[j] << " "<<p.depth;
			sample_file << "\n";
			st=st+sample_freq;
		}

	}

	return 0;
}

